# malrob/family_evasion.py
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# ----------------------------
# Config
# ----------------------------
@dataclass(frozen=True)
class FamilyEvasionConfig:
    # Which eps values exist in your saved artifacts filenames
    eps_list: Sequence[float] = (0.01, 0.05, 0.10)

    # Which attacks to include (must match filenames: pred_nn_{attack}_eps{eps}_fixed.npy)
    attacks: Sequence[str] = ("FGSM", "PGD")

    # Top-K families by frequency (excluding "unknown" by default)
    top_k: int = 5
    exclude_families: Tuple[str, ...] = ("unknown",)

    # Safety: if True, assert pred arrays align with fam_mal
    strict_alignment: bool = True


# ----------------------------
# Loading helpers
# ----------------------------
def load_fam_mal(artifacts_dir: Path) -> pd.Series:
    """
    Load malware-only family labels saved by Notebook 03 (fam_mal.csv).
    Returns a pandas Series of strings aligned to malware-only predictions arrays.
    """
    artifacts_dir = Path(artifacts_dir)
    p = artifacts_dir / "fam_mal.csv"
    if not p.exists():
        raise FileNotFoundError(f"Missing fam_mal.csv at: {p}")
    fam_mal = pd.read_csv(p)["family"].astype(str)
    return fam_mal


def load_clean_thresholds(artifacts_dir: Path) -> Dict[str, float]:
    """
    Load clean_thresholds.json (not strictly required for Notebook 04 metrics,
    but useful for reporting and provenance).
    """
    artifacts_dir = Path(artifacts_dir)
    p = artifacts_dir / "clean_thresholds.json"
    if not p.exists():
        raise FileNotFoundError(f"Missing clean_thresholds.json at: {p}")
    import json
    with open(p, "r", encoding="utf-8") as f:
        d = json.load(f)
    return {"clean_thr_nn": float(d["clean_thr_nn"]), "clean_thr_rf": float(d["clean_thr_rf"])}


def select_top_families(
    fam_mal: pd.Series,
    *,
    top_k: int,
    exclude: Iterable[str] = ("unknown",),
) -> List[str]:
    """
    Select the top-K most frequent families among malware-only test set.
    """
    counts = fam_mal.value_counts()
    if exclude:
        counts = counts.drop(labels=list(exclude), errors="ignore")
    return counts.head(int(top_k)).index.tolist()


def _attack_key(attack: str) -> str:
    # filenames are lower-case in your notebook
    return str(attack).strip().lower()


def _eps_to_token(eps: float) -> str:
    """
    IMPORTANT: your filenames include eps as Python prints it, e.g.:
      eps0.01, eps0.05, eps0.1  (NOTE 0.10 becomes 0.1 in original notebook)
    So we replicate that behavior:
      str(0.10) -> "0.1"
    """
    return str(float(eps))


def _pred_paths(
    artifacts_dir: Path,
    *,
    attack: str,
    eps: float,
) -> Tuple[Path, Path]:
    """
    Build expected prediction artifact paths for NN and RF-transfer.
    """
    a = _attack_key(attack)
    e = _eps_to_token(eps)
    nn_path = artifacts_dir / f"pred_nn_{a}_eps{e}_fixed.npy"
    rf_path = artifacts_dir / f"pred_rf_transfer_{a}_eps{e}_fixed.npy"
    return nn_path, rf_path


# ----------------------------
# Core metrics
# ----------------------------
def family_fn_rate(y_pred: np.ndarray, families: pd.Series) -> Dict[str, float]:
    """
    Compute per-family FN rate (malware -> benign) for malware-only subset.

    y_pred: numpy array, 1 = malware, 0 = benign
    families: pandas Series aligned with y_pred
    """
    y_pred = np.asarray(y_pred).astype(int)
    if len(y_pred) != len(families):
        raise ValueError(f"Length mismatch: y_pred={len(y_pred)} vs families={len(families)}")

    out: Dict[str, float] = {}
    for fam in families.unique():
        idx = (families == fam).to_numpy()
        out[str(fam)] = float((y_pred[idx] == 0).mean())
    return out


def build_family_evasion_table(
    *,
    artifacts_dir: Path,
    cfg: FamilyEvasionConfig = FamilyEvasionConfig(),
    top_families: Optional[Sequence[str]] = None,
) -> pd.DataFrame:
    """
    Build the long-format table:
      columns: attack, eps, family, model, fn_rate

    Reads:
      fam_mal.csv
      pred_nn_{attack}_eps{eps}_fixed.npy
      pred_rf_transfer_{attack}_eps{eps}_fixed.npy
    """
    artifacts_dir = Path(artifacts_dir)
    fam_mal = load_fam_mal(artifacts_dir)

    if top_families is None:
        top_families = select_top_families(
            fam_mal,
            top_k=cfg.top_k,
            exclude=cfg.exclude_families,
        )
    top_families = list(top_families)

    rows: List[Dict] = []

    for attack in cfg.attacks:
        for eps in cfg.eps_list:
            nn_path, rf_path = _pred_paths(artifacts_dir, attack=attack, eps=eps)

            if not nn_path.exists():
                print(f"[WARN] Missing NN preds for {attack} eps={eps}: {nn_path.name}")
                continue
            if not rf_path.exists():
                print(f"[WARN] Missing RF-transfer preds for {attack} eps={eps}: {rf_path.name}")
                continue

            nn_pred = np.load(nn_path)
            rf_pred = np.load(rf_path)

            if cfg.strict_alignment:
                assert len(nn_pred) == len(fam_mal), (
                    f"{nn_path.name} len {len(nn_pred)} != fam_mal len {len(fam_mal)}"
                )
                assert len(rf_pred) == len(fam_mal), (
                    f"{rf_path.name} len {len(rf_pred)} != fam_mal len {len(fam_mal)}"
                )

            fam_rates_nn = family_fn_rate(nn_pred, fam_mal)
            fam_rates_rf = family_fn_rate(rf_pred, fam_mal)

            for fam in top_families:
                if fam not in fam_rates_nn or fam not in fam_rates_rf:
                    # defensive: family might be absent if excluded/rare
                    continue

                rows.append(
                    {"attack": str(attack).upper(), "eps": float(eps), "family": fam, "model": "NN", "fn_rate": fam_rates_nn[fam]}
                )
                rows.append(
                    {"attack": str(attack).upper(), "eps": float(eps), "family": fam, "model": "RF-transfer", "fn_rate": fam_rates_rf[fam]}
                )

    df_fam = pd.DataFrame(rows)
    return df_fam


def compute_family_delta_table(df_fam: pd.DataFrame) -> pd.DataFrame:
    """
    Pivot to wide format and compute:
      delta_NN_minus_RF = NN - RF-transfer
    """
    pivot = (
        df_fam.pivot_table(
            index=["attack", "eps", "family"],
            columns="model",
            values="fn_rate",
            aggfunc="mean",
        )
        .reset_index()
    )

    # Ensure expected columns exist
    for col in ["NN", "RF-transfer"]:
        if col not in pivot.columns:
            pivot[col] = np.nan

    pivot["delta_NN_minus_RF"] = pivot["NN"] - pivot["RF-transfer"]
    return pivot


def rank_families_by_risk(
    df_delta: pd.DataFrame,
    *,
    agg: str = "mean",
) -> pd.DataFrame:
    """
    Produce a family risk ranking table aggregated across eps and attacks.

    Default: mean delta across eps and attacks.
    Higher delta => NN more vulnerable than RF-transfer on that family.
    """
    if agg not in {"mean", "max", "median"}:
        raise ValueError("agg must be one of: {'mean','max','median'}")

    grp = df_delta.groupby("family", as_index=False)["delta_NN_minus_RF"]
    if agg == "mean":
        out = grp.mean(numeric_only=True)
    elif agg == "max":
        out = grp.max(numeric_only=True)
    else:
        out = grp.median(numeric_only=True)

    out = out.sort_values("delta_NN_minus_RF", ascending=False).reset_index(drop=True)
    out["risk_rank"] = np.arange(1, len(out) + 1)
    return out[["risk_rank", "family", "delta_NN_minus_RF"]]


# ----------------------------
# Saving + plotting
# ----------------------------
def save_family_outputs(
    *,
    df_fam: pd.DataFrame,
    results_dir: Path,
    filename: str = "family_evasion_summary.csv",
) -> Path:
    """
    Save the long-format family evasion table.
    """
    results_dir = Path(results_dir)
    results_dir.mkdir(parents=True, exist_ok=True)
    out_path = results_dir / filename
    df_fam.to_csv(out_path, index=False)
    print("[INFO] Saved:", out_path)
    return out_path


def plot_family_curves(
    *,
    df_fam: pd.DataFrame,
    results_dir: Path,
    top_families: Sequence[str],
    attacks: Sequence[str] = ("FGSM", "PGD"),
    show: bool = True,
) -> List[Path]:
    """
    Replicates Notebook 04 plots:
      per-attack figures with NN (solid) vs RF-transfer (dashed), top families only.
    """
    results_dir = Path(results_dir)
    plots_dir = results_dir / "plots"
    plots_dir.mkdir(parents=True, exist_ok=True)

    saved: List[Path] = []

    for attack in attacks:
        sub = df_fam[df_fam["attack"] == str(attack).upper()]
        if sub.empty:
            print(f"[WARN] No rows for {attack}; skipping plot.")
            continue

        fig, ax = plt.subplots(figsize=(9, 5))

        for fam in top_families:
            fam_nn = sub[(sub["family"] == fam) & (sub["model"] == "NN")].sort_values("eps")
            fam_rf = sub[(sub["family"] == fam) & (sub["model"] == "RF-transfer")].sort_values("eps")

            if fam_nn.empty or fam_rf.empty:
                continue

            ax.plot(
                fam_nn["eps"].values,
                fam_nn["fn_rate"].values,
                marker="o",
                linestyle="-",
                label=f"{fam} (NN)",
            )
            ax.plot(
                fam_rf["eps"].values,
                fam_rf["fn_rate"].values,
                marker="x",
                linestyle="--",
                label=f"{fam} (RF-transfer)",
            )

        ax.set_title(f"Family-Level Targeted Evasion – {str(attack).upper()}")
        ax.set_xlabel("Epsilon (perturbation strength)")
        ax.set_ylabel("False Negative Rate (malware → benign)")
        ax.grid(True)
        ax.legend(ncol=2, fontsize=9)
        plt.tight_layout()

        out_path = plots_dir / f"family_fn_rate_nn_vs_rf_{str(attack).lower()}.png"
        fig.savefig(out_path, dpi=300, bbox_inches="tight")
        
        if show:
            plt.show()
        else:
            plt.close(fig)

        print("[INFO] Saved plot:", out_path)
        saved.append(out_path)

    return saved


def plot_combined_attacks_panel(
    *,
    df_fam: pd.DataFrame,
    results_dir: Path,
    top_families: Sequence[str],
    show: bool = True,
) -> Path:
    """
    Optional poster-friendly single panel:
      - FGSM vs PGD distinguished by linestyle
      - NN vs RF-transfer
    """
    results_dir = Path(results_dir)
    plots_dir = results_dir / "plots"
    plots_dir.mkdir(parents=True, exist_ok=True)

    fig, ax = plt.subplots(figsize=(10, 5))

    # line style by attack
    attack_styles = {"FGSM": "-", "PGD": "--"}
    # marker by model
    model_markers = {"NN": "o", "RF-transfer": "x"}

    for fam in top_families:
        for attack, ls in attack_styles.items():
            sub = df_fam[(df_fam["family"] == fam) & (df_fam["attack"] == attack)]
            for model, mk in model_markers.items():
                s2 = sub[sub["model"] == model].sort_values("eps")
                if s2.empty:
                    continue
                ax.plot(
                    s2["eps"].values,
                    s2["fn_rate"].values,
                    linestyle=ls,
                    marker=mk,
                    label=f"{fam} | {attack} | {model}",
                )

    ax.set_title("Family-Level Targeted Evasion (FGSM + PGD)")
    ax.set_xlabel("Epsilon (scaled feature space)")
    ax.set_ylabel("False Negative Rate (malware → benign)")
    ax.grid(True)
    ax.legend(fontsize=8, ncol=2)
    plt.tight_layout()

    out_path = plots_dir / "family_fn_rate_combined_fgsm_pgd.png"
    fig.savefig(out_path, dpi=300, bbox_inches="tight")

    if show:
        plt.show()
    else:
        plt.close(fig)

    print("[INFO] Saved combined plot:", out_path)
    return out_path


def export_latex_tables(
    *,
    df_delta: pd.DataFrame,
    df_risk: pd.DataFrame,
    results_dir: Path,
) -> Tuple[Path, Path]:
    """
    Export LaTeX-ready tables for your report/poster appendix.
    """
    results_dir = Path(results_dir)
    results_dir.mkdir(parents=True, exist_ok=True)

    # Table 1: Delta per attack/eps/family
    latex_delta = results_dir / "table_family_delta.tex"
    latex_risk = results_dir / "table_family_risk_ranking.tex"

    # Keep consistent ordering
    df_delta_out = df_delta.sort_values(["attack", "eps", "family"]).reset_index(drop=True)
    df_risk_out = df_risk.sort_values("risk_rank").reset_index(drop=True)

    latex_delta.write_text(
        df_delta_out.to_latex(index=False, float_format=lambda x: f"{x:.4f}"),
        encoding="utf-8",
    )
    latex_risk.write_text(
        df_risk_out.to_latex(index=False, float_format=lambda x: f"{x:.4f}"),
        encoding="utf-8",
    )

    print("[INFO] Saved LaTeX:", latex_delta)
    print("[INFO] Saved LaTeX:", latex_risk)
    return latex_delta, latex_risk


__all__ = [
    "FamilyEvasionConfig",
    "load_fam_mal",
    "load_clean_thresholds",
    "select_top_families",
    "family_fn_rate",
    "build_family_evasion_table",
    "compute_family_delta_table",
    "rank_families_by_risk",
    "save_family_outputs",
    "plot_family_curves",
    "plot_combined_attacks_panel",
    "export_latex_tables",
]